var f=Object.defineProperty;var m=(t,e,a)=>e in t?f(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a;var p=(t,e,a)=>m(t,typeof e!="symbol"?e+"":e,a);function c(t){return new Promise((e,a)=>{t.oncomplete=t.onsuccess=()=>e(t.result),t.onabort=t.onerror=()=>a(t.error)})}function w(t,e){const a=indexedDB.open(t);a.onupgradeneeded=()=>a.result.createObjectStore(e);const r=c(a);return(s,n)=>r.then(o=>n(o.transaction(e,s).objectStore(e)))}let i;function h(){return i||(i=w("keyval-store","keyval")),i}function y(t,e=h()){return e("readonly",a=>c(a.get(t)))}function R(t,e,a=h()){return a("readwrite",r=>(r.put(e,t),c(r.transaction)))}function I(t,e=h()){return e("readwrite",a=>(a.delete(t),c(a.transaction)))}const u=typeof indexedDB>"u"?localStorage:{getItem:async t=>await y(t)??null,setItem:async(t,e)=>await R(t,e),removeItem:async t=>await I(t)},b=1e3*60*60;class v{async getCache(e){const a=await u.getItem(e);return a?JSON.parse(a):null}async setCache(e,a,r){const s={etag:a,value:r,expiredAt:Date.now()+b};await u.setItem(e,JSON.stringify(s))}async removeCache(e){await u.removeItem(e)}}class C{constructor(){p(this,"storage",new v)}async handleRequest(e){const a=this.getCacheKey(e),r=await this.storage.getCache(a);if(r){if(r.expiredAt>Date.now())return this.createResponse(r.value,{limit:0,remaining:0});this.storage.removeCache(a)}const s={Accept:"application/vnd.github.v3+json"};e.token&&(s.Authorization=`Bearer ${e.token}`),r!=null&&r.etag&&(s["If-None-Match"]=r.etag);try{const n=await this.fetchData(e,s),o={limit:parseInt(n.headers.get("X-Ratelimit-Limit")||"0"),remaining:parseInt(n.headers.get("X-Ratelimit-Remaining")||"0")};if(n.status===304&&r)return this.createResponse(r.value,o);if(!n.ok)throw new Error(`GitHub API request failed: ${n.status}`);const g=await n.json(),l=this.parseResponse(g),d=n.headers.get("ETag");return d&&await this.storage.setCache(a,d,l),this.createResponse(l,o)}catch(n){return this.createErrorResponse(n.message)}}createResponse(e,a){return{data:e,rateLimit:a}}createErrorResponse(e){return{error:e}}}class S extends C{getCacheKey(e){return`${e.owner}/${e.repo}/default-branch`}fetchData({owner:e,repo:a},r){return fetch(`https://api.github.com/repos/${e}/${a}`,{headers:r})}parseResponse(e){return e.default_branch}}const k=new S;self.onmessage=async t=>{const e=await k.handleRequest(t.data);self.postMessage(e)};
